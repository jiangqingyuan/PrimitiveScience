# 算法

简单的算法，可能时间多，但是空间少。
复杂的算法，可能时间少，但是空间多。

嵌入式或空间受限的应用程序（如GNU/Linux或FreeBSD在软盘上发布的各种发布版），它们的代码可能会为了节省几个字节的空间而增长很多。
但是代码段可能变长。

专为演示算法运作原理而编写的代码，其使用的标识符可能会长得离谱。
所以不为了演示，而是为了实际应用而编写的代码，其标识符可能会短得离谱。
为了防逆向，可能要代码难以被阅读。但好像是徒劳的。
归根结底要自己知道怎么做。

要注意非功能需求，留意如何满足这样的需求。

可以把源代码当做是一种掌握新环境下基本情况的途径。但要注意从小型的程序开始阅读；不要马上一头扎到大型系统的研究中。
下一步就是主动地修改代码，以此来检验自己对代码的理解。
还是要从小的改动做起，然后逐渐扩大范围。
通过积极地介入现实的代码，可以快速地了解新环境下的一些基本情况。
在掌握之后，要考虑投入一些努力（可能还需要投入一些资金），采取更系统的方式来学习该环境。
阅读相关的书籍、文档或手册，或者参加培训课程；这两种学习方式互为补充。

另外一种积极地阅读现有代码的方式是改进它，而这些代码都是被当做文献来阅读的。

想知道怎么做到，可能读代码比读书更可靠。

要清楚自己在找什么：是一个系统调用、一种算法、一段代码，还是一种架构？设计一种发现目标代码的策略。
不要沿着不相关的路径往下走。

不同的搜索策略适用于不同的目的。
你可能需要跟踪指令执行的序列，运行程序并在关键位置设置断点，或者对代码进行文本查找，以找出特定的代码或数据元素。可以借助工具（参见第10章），但不要局限于其中任何一种。
如果一种策略不能很快产生所期待的结果，那就放弃它，然后尝试其他的策略。
切记，要找的代码就在那里，我们只需要找到它。
如果你觉得在原来的上下文中理解代码有困难，那就将它复制到一个临时文件中，删除所有不相关的部分。这一过程的正式名称叫做切片（Slicing）

在向系统中增加新功能时，首要任务是找到实现类似特性的代码，将其作为待实现功能的一个模板。

重构时，从可运转的系统开始，并要确保完成后其仍可正常运转。
一套有针对性的测试用例可以帮助满足这一约束，因此应该从编写测试用例开始展开重构。

如果代码的新环境完全不同于原来的环境（例如，将命令行工具移植到图形窗口环境中），就必须采用别的方法。在此，最小化代码阅读量的唯一希望是把关注的焦点聚集在老代码和新环境之间的接口有区别的地方。对于所述例子，这意味着要专注于同用户有交互的代码，而完全忽略系统中所有与算法有关的方面。


编写可重用的软件会增加50%的开发工作量。，关键理念是控制期望值。代码的可重用性是一个很诱人，但难以掌握的思想；调低期望值就不会感到失望。

在寻找可重用的代码以解决所面对的具体问题时，首先要将可以解决这一问题的代码分离出来。
如果打算重用的代码十分棘手、难以理解，也不易分离，可以试着寻找粒度更大一些的包，甚至其他代码。例如，不要钻牛角尖去梳理某个代码段与其周围部分之间难于处理的关系，而是使用整个库、组件、进程，甚至代码所在的系统。

代码的非功能性问题也应该给予同等的重视。代码是否符合组织的开发规范和风格？是否存在重构的可能？部分代码是否可以编写得更易读或者更加高效？某些部分是否可以重用现有的库或组件？在复查软件系统时，要注意系统是由很多部分组成的，而非只是可执行的语句。
还要检查以下内容：文件和目录结构，构建和配置过程，用户界面，以及系统文档。

我们所观察到的并不是大自然本身，而是其在我们的观察方法下所展现出的特性。
一定要还原。
多数情形下，代码阅读是一个自底向上（bottom-up）的活动。